<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>船体物理模拟与设计系统</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        
        .header {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 8px;
            color: #2c3e50;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #7f8c8d;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            gap: 15px;
            height: calc(100vh - 200px);
        }
        
        .design-panel {
            width: 300px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }
        
        .simulation-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }
        
        #simulationCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #3498db;
            cursor: crosshair;
        }
        
        .control-section {
            margin-bottom: 20px;
        }
        
        .control-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        
        .material-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .material-btn {
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            text-align: center;
        }
        
        .material-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .material-btn:active, .material-btn.selected {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .steel { background: linear-gradient(to bottom, #95a5a6, #7f8c8d); color: white; }
        .wood { background: linear-gradient(to bottom, #e67e22, #d35400); color: white; }
        .aluminum { background: linear-gradient(to bottom, #bdc3c7, #ecf0f1); color: #2c3e50; }
        .fiberglass { background: linear-gradient(to bottom, #34495e, #2c3e50); color: white; }
        .foam { background: linear-gradient(to bottom, #ecf0f1, #bdc3c7); color: #2c3e50; }
        
        .physics-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .action-btn {
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            color: white;
            transition: all 0.2s;
        }
        
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .action-btn:active {
            transform: translateY(0);
        }
        
        .action-btn.reset {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
        }
        
        .data-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(236, 240, 241, 0.95);
            padding: 15px;
            border-radius: 12px;
            min-width: 200px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }
        
        .data-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        
        .data-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .data-value {
            font-weight: bold;
            color: #2c3e50;
        }
        
        .instructions {
            background: rgba(236, 240, 241, 0.95);
            padding: 15px;
            border-radius: 12px;
            margin-top: 15px;
            font-size: 0.95rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }
        
        .instructions h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .instructions p {
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        .drawing-tools {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .draw-tool-btn {
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(to bottom, #9b59b6, #8e44ad);
            color: white;
            font-weight: bold;
            flex: 1;
            transition: all 0.2s;
        }
        
        .draw-tool-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .draw-tool-btn.active {
            background: linear-gradient(to bottom, #e67e22, #d35400);
            transform: translateY(0);
        }
        
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                height: auto;
            }
            
            .design-panel {
                width: 100%;
                margin-bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>船体物理模拟与设计系统</h1>
        <p class="subtitle">绘制船体 · 物理模拟 · 实时交互</p>
    </div>
    
    <div class="main-container">
        <div class="design-panel">
            <div class="control-section">
                <div class="control-title">绘图工具</div>
                <div class="drawing-tools">
                    <button class="draw-tool-btn active" id="pencilTool"><i class="fas fa-pencil-alt"></i> 铅笔</button>
                    <button class="draw-tool-btn" id="shapeTool"><i class="fas fa-vector-square"></i> 形状</button>
                    <button class="draw-tool-btn" id="eraseTool"><i class="fas fa-eraser"></i> 擦除</button>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-title">画笔设置</div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>画笔大小: </span>
                        <span id="brushSizeValue">5px</span>
                    </div>
                    <input type="range" id="brushSize" min="1" max="20" step="1" value="5">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>压感强度: </span>
                        <span id="pressureValue">0.5</span>
                    </div>
                    <input type="range" id="pressureSensitivity" min="0" max="1" step="0.1" value="0.5">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>平滑度: </span>
                        <span id="smoothnessValue">0.7</span>
                    </div>
                    <input type="range" id="smoothness" min="0" max="1" step="0.1" value="0.7">
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-title">船体材质选择</div>
                <div class="material-grid">
                    <button class="material-btn steel" data-density="7.8">钢铁</button>
                    <button class="material-btn wood" data-density="0.8">木材</button>
                    <button class="material-btn aluminum" data-density="2.7">铝材</button>
                    <button class="material-btn fiberglass" data-density="1.8">玻璃钢</button>
                    <button class="material-btn foam" data-density="0.2">泡沫</button>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-title">物理参数调整</div>
                <div class="physics-controls">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>水体密度: </span>
                            <span id="waterDensityValue">1.025 g/cm³</span>
                        </div>
                        <input type="range" id="waterDensity" min="0.8" max="1.2" step="0.005" value="1.025">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>重力加速度: </span>
                            <span id="gravityValue">9.81 m/s²</span>
                        </div>
                        <input type="range" id="gravity" min="1" max="20" step="0.1" value="9.81">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>波浪强度: </span>
                            <span id="waveValue">0.5</span>
                        </div>
                        <input type="range" id="waveStrength" min="0" max="2" step="0.1" value="0.5">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>水体粘度: </span>
                            <span id="viscosityValue">0.01</span>
                        </div>
                        <input type="range" id="viscosity" min="0.001" max="0.1" step="0.001" value="0.01">
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <button class="action-btn" id="startSim">开始模拟</button>
                <button class="action-btn reset" id="resetSim">重置模拟</button>
                <button class="action-btn" id="clearHull">清除船体</button>
            </div>
        </div>
        
        <div class="simulation-container">
            <canvas id="simulationCanvas"></canvas>
            
            <div class="data-panel">
                <div class="data-title">实时物理数据</div>
                <div class="data-item">
                    <span>排水量:</span>
                    <span class="data-value" id="displacement">0.0 t</span>
                </div>
                <div class="data-item">
                    <span>浮力:</span>
                    <span class="data-value" id="buoyancy">0.0 N</span>
                </div>
                <div class="data-item">
                    <span>吃水深度:</span>
                    <span class="data-value" id="draft">0.0 m</span>
                </div>
                <div class="data-item">
                    <span>稳定性系数:</span>
                    <span class="data-value" id="stability">0.0</span>
                </div>
                <div class="data-item">
                    <span>重心高度:</span>
                    <span class="data-value" id="centerOfGravity">0.0 m</span>
                </div>
                <div class="data-item">
                    <span>浮心高度:</span>
                    <span class="data-value" id="centerOfBuoyancy">0.0 m</span>
                </div>
                <div class="data-item">
                    <span>横摇周期:</span>
                    <span class="data-value" id="rollPeriod">0.0 s</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="instructions">
        <h3>使用说明</h3>
        <p>1. <strong>绘制船体</strong> - 使用绘图工具在画布上设计船体形状。铅笔工具提供自由绘制，形状工具可创建几何图形</p>
        <p>2. <strong>调整画笔</strong> - 设置画笔大小、压感强度和平滑度，获得iPad般的绘图体验</p>
        <p>3. <strong>选择材质</strong> - 不同材质具有不同密度，影响船体浮力和稳定性</p>
        <p>4. <strong>调整物理参数</strong> - 修改水体密度、重力、波浪强度等物理参数</p>
        <p>5. <strong>开始模拟</strong> - 点击"开始模拟"观察船体在水中的物理行为</p>
        <p>6. <strong>实时数据</strong> - 查看右侧数据面板获取实时物理参数和船体特性</p>
    </div>

    <script>
        // 初始化变量和常量
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const startSimBtn = document.getElementById('startSim');
        const resetSimBtn = document.getElementById('resetSim');
        const clearHullBtn = document.getElementById('clearHull');
        const pencilToolBtn = document.getElementById('pencilTool');
        const shapeToolBtn = document.getElementById('shapeTool');
        const eraseToolBtn = document.getElementById('eraseTool');
        const brushSizeSlider = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const pressureSlider = document.getElementById('pressureSensitivity');
        const pressureValue = document.getElementById('pressureValue');
        const smoothnessSlider = document.getElementById('smoothness');
        const smoothnessValue = document.getElementById('smoothnessValue');
        
        // 物理参数
        let waterDensity = 1.025; // g/cm³ (海水密度)
        let gravity = 9.81; // m/s²
        let waveStrength = 0.5;
        let waterViscosity = 0.01; // 水体粘度
        let selectedMaterial = 'steel';
        let materialDensity = 7.8; // g/cm³
        
        // 绘图变量
        let hullPoints = [];
        let isDrawing = false;
        let isSimulating = false;
        let currentTool = 'pencil';
        let brushSize = 5;
        let pressureSensitivity = 0.5;
        let smoothness = 0.7;
        let lastX, lastY;
        
        // 物理计算变量
        let displacement = 0;
        let buoyancyForce = 0;
        let draft = 0;
        let stabilityValue = 0;
        let centerOfGravity = {x: 0, y: 0};
        let centerOfBuoyancy = {x: 0, y: 0};
        let rollPeriod = 0;
        
        // 调整画布大小
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            drawScene();
        }
        
        // 绘制场景
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制水面
            drawWater();
            
            // 绘制船体
            if (hullPoints.length > 0) {
                drawHull();
            }
            
            // 绘制网格和参考线
            drawGrid();
        }
        
        // 绘制水面
        function drawWater() {
            const waterLevel = canvas.height * 0.7;
            
            ctx.beginPath();
            ctx.moveTo(0, waterLevel);
            
            // 添加波浪效果
            if (isSimulating && waveStrength > 0) {
                const now = Date.now() / 1000;
                for (let x = 0; x < canvas.width; x += 5) {
                    const y = waterLevel + Math.sin(x / 30 + now) * 5 * waveStrength;
                    ctx.lineTo(x, y);
                }
            } else {
                ctx.lineTo(canvas.width, waterLevel);
            }
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            
            ctx.fillStyle = 'rgba(52, 152, 219, 0.6)';
            ctx.fill();
            
            // 水面线
            ctx.beginPath();
            ctx.moveTo(0, waterLevel);
            ctx.lineTo(canvas.width, waterLevel);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.stroke();
        }
        
        // 绘制船体
        function drawHull() {
            if (hullPoints.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(hullPoints[0].x, hullPoints[0].y);
            
            for (let i = 1; i < hullPoints.length; i++) {
                // 使用二次贝塞尔曲线平滑路径
                if (i < hullPoints.length - 1) {
                    const xc = (hullPoints[i].x + hullPoints[i + 1].x) / 2;
                    const yc = (hullPoints[i].y + hullPoints[i + 1].y) / 2;
                    ctx.quadraticCurveTo(hullPoints[i].x, hullPoints[i].y, xc, yc);
                } else {
                    ctx.lineTo(hullPoints[i].x, hullPoints[i].y);
                }
            }
            
            // 闭合船体
            if (hullPoints.length > 2) {
                ctx.closePath();
            }
            
            ctx.fillStyle = getMaterialColor(selectedMaterial);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();
            
            // 绘制顶点
            for (const point of hullPoints) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
            }
            
            // 绘制重心和浮心
            if (isSimulating) {
                drawCenters();
            }
        }
        
        // 获取材质颜色
        function getMaterialColor(material) {
            const colors = {
                'steel': '#95a5a6',
                'wood': '#e67e22',
                'aluminum': '#bdc3c7',
                'fiberglass': '#34495e',
                'foam': '#ecf0f1'
            };
            return colors[material] || '#95a5a6';
        }
        
        // 绘制重心和浮心
        function drawCenters() {
            // 绘制重心
            ctx.beginPath();
            ctx.arc(centerOfGravity.x, centerOfGravity.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#e74c3c';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 绘制浮心
            ctx.beginPath();
            ctx.arc(centerOfBuoyancy.x, centerOfBuoyancy.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#3498db';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 绘制连接线
            ctx.beginPath();
            ctx.moveTo(centerOfGravity.x, centerOfGravity.y);
            ctx.lineTo(centerOfBuoyancy.x, centerOfBuoyancy.y);
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 绘制图例
            ctx.font = '12px Arial';
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('重心', centerOfGravity.x + 10, centerOfGravity.y);
            ctx.fillStyle = '#3498db';
            ctx.fillText('浮心', centerOfBuoyancy.x + 10, centerOfBuoyancy.y);
        }
        
        // 绘制网格和参考线
        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            
            // 垂直网格线
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // 水平网格线
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // 绘制水位线标记
            const waterLevel = canvas.height * 0.7;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, waterLevel);
            ctx.lineTo(canvas.width, waterLevel);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillText('水位线', 10, waterLevel - 5);
        }
        
        // 计算物理特性
        function calculatePhysics() {
            if (hullPoints.length < 3) return;
            
            // 计算船体面积和质心
            let area = 0;
            let centerX = 0;
            let centerY = 0;
            
            for (let i = 0; i < hullPoints.length; i++) {
                const j = (i + 1) % hullPoints.length;
                const cross = hullPoints[i].x * hullPoints[j].y - hullPoints[j].x * hullPoints[i].y;
                area += cross;
                centerX += (hullPoints[i].x + hullPoints[j].x) * cross;
                centerY += (hullPoints[i].y + hullPoints[j].y) * cross;
            }
            
            area = Math.abs(area / 2);
            centerX = centerX / (6 * area);
            centerY = centerY / (6 * area);
            
            // 计算排水量 (阿基米德原理)
            const waterLevel = canvas.height * 0.7;
            const submergedArea = calculateSubmergedArea(waterLevel);
            displacement = submergedArea * 0.01 * materialDensity;
            
            // 计算浮力
            buoyancyForce = displacement * waterDensity * gravity * 1000;
            
            // 计算吃水深度
            draft = calculateDraft(waterLevel);
            
            // 计算重心和浮心
            centerOfGravity = {x: centerX, y: centerY};
            centerOfBuoyancy = calculateCenterOfBuoyancy(waterLevel);
            
            // 计算稳定性
            stabilityValue = calculateStability();
            
            // 计算横摇周期
            rollPeriod = calculateRollPeriod();
            
            // 更新数据显示
            updateDataDisplay();
        }
        
        // 计算水下部分面积
        function calculateSubmergedArea(waterLevel) {
            let submergedArea = 0;
            for (let i = 0; i < hullPoints.length; i++) {
                const j = (i + 1) % hullPoints.length;
                const p1 = hullPoints[i];
                const p2 = hullPoints[j];
                
                // 简单估算水下面积
                if (p1.y > waterLevel || p2.y > waterLevel) {
                    submergedArea += Math.abs((p1.x - p2.x) * (waterLevel - Math.min(p1.y, p2.y))) / 2;
                }
            }
            return Math.max(0, submergedArea);
        }
        
        // 计算吃水深度
        function calculateDraft(waterLevel) {
            let maxDepth = 0;
            for (const point of hullPoints) {
                const depth = Math.max(0, point.y - waterLevel);
                maxDepth = Math.max(maxDepth, depth);
            }
            return maxDepth;
        }
        
        // 计算浮心位置
        function calculateCenterOfBuoyancy(waterLevel) {
            // 简化计算：浮心位于重心下方一定位置
            return {
                x: centerOfGravity.x,
                y: centerOfGravity.y + draft / 2
            };
        }
        
        // 计算稳定性
        function calculateStability() {
            // 稳定性系数：浮心与重心的垂直距离
            const verticalDistance = Math.abs(centerOfBuoyancy.y - centerOfGravity.y);
            return verticalDistance / draft;
        }
        
        // 计算横摇周期
        function calculateRollPeriod() {
            // 简化的横摇周期计算公式
            if (stabilityValue <= 0) return 0;
            return 2 * Math.PI * Math.sqrt(draft / (gravity * stabilityValue));
        }
        
        // 更新数据面板
        function updateDataDisplay() {
            document.getElementById('displacement').textContent = displacement.toFixed(2) + ' t';
            document.getElementById('buoyancy').textContent = buoyancyForce.toFixed(2) + ' N';
            document.getElementById('draft').textContent = draft.toFixed(2) + ' m';
            document.getElementById('stability').textContent = stabilityValue.toFixed(2);
            document.getElementById('centerOfGravity').textContent = 
                centerOfGravity.x.toFixed(1) + ', ' + centerOfGravity.y.toFixed(1);
            document.getElementById('centerOfBuoyancy').textContent = 
                centerOfBuoyancy.x.toFixed(1) + ', ' + centerOfBuoyancy.y.toFixed(1);
            document.getElementById('rollPeriod').textContent = rollPeriod.toFixed(2) + ' s';
        }
        
        // 初始化事件监听
        function initEventListeners() {
            // 画布交互
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDrawing);
            canvas.addEventListener('mouseleave', endDrawing);
            
            // 触摸设备支持
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // 材质选择
            document.querySelectorAll('.material-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.material-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedMaterial = btn.dataset.type;
                    materialDensity = parseFloat(btn.dataset.density);
                    if (isSimulating) calculatePhysics();
                });
            });
            
            // 物理参数调整
            document.getElementById('waterDensity').addEventListener('input', () => {
                waterDensity = parseFloat(document.getElementById('waterDensity').value);
                document.getElementById('waterDensityValue').textContent = waterDensity.toFixed(3) + ' g/cm³';
                if (isSimulating) calculatePhysics();
            });
            
            document.getElementById('gravity').addEventListener('input', () => {
                gravity = parseFloat(document.getElementById('gravity').value);
                document.getElementById('gravityValue').textContent = gravity.toFixed(2) + ' m/s²';
                if (isSimulating) calculatePhysics();
            });
            
            document.getElementById('waveStrength').addEventListener('input', () => {
                waveStrength = parseFloat(document.getElementById('waveStrength').value);
                document.getElementById('waveValue').textContent = waveStrength.toFixed(1);
            });
            
            document.getElementById('viscosity').addEventListener('input', () => {
                waterViscosity = parseFloat(document.getElementById('viscosity').value);
                document.getElementById('viscosityValue').textContent = waterViscosity.toFixed(3);
            });
            
            // 绘图工具选择
            pencilToolBtn.addEventListener('click', () => {
                setActiveTool('pencil');
            });
            
            shapeToolBtn.addEventListener('click', () => {
                setActiveTool('shape');
            });
            
            eraseToolBtn.addEventListener('click', () => {
                setActiveTool('erase');
            });
            
            // 画笔设置
            brushSizeSlider.addEventListener('input', () => {
                brushSize = parseInt(brushSizeSlider.value);
                brushSizeValue.textContent = brushSize + 'px';
            });
            
            pressureSlider.addEventListener('input', () => {
                pressureSensitivity = parseFloat(pressureSlider.value);
                pressureValue.textContent = pressureSensitivity.toFixed(1);
            });
            
            smoothnessSlider.addEventListener('input', () => {
                smoothness = parseFloat(smoothnessSlider.value);
                smoothnessValue.textContent = smoothness.toFixed(1);
            });
            
            // 模拟控制
            startSimBtn.addEventListener('click', startSimulation);
            resetSimBtn.addEventListener('click', resetSimulation);
            clearHullBtn.addEventListener('click', clearHull);
            
            // 窗口调整大小
            window.addEventListener('resize', resizeCanvas);
        }
        
        // 设置当前工具
        function setActiveTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.draw-tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            switch(tool) {
                case 'pencil':
                    pencilToolBtn.classList.add('active');
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'shape':
                    shapeToolBtn.classList.add('active');
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'erase':
                    eraseToolBtn.classList.add('active');
                    canvas.style.cursor = 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\'><circle cx=\'12\' cy=\'12\' r=\'10\' fill=\'%23e74c3c\'/></svg>") 12 12, auto';
                    break;
            }
        }
        
        // 开始绘制
        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            lastX = x;
            lastY = y;
            
            if (currentTool === 'pencil') {
                hullPoints.push({x, y});
            } else if (currentTool === 'erase') {
                erasePoint(x, y);
            }
            
            drawScene();
            e.preventDefault();
        }
        
        // 绘制
        function draw(e) {
            if (!isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentTool === 'pencil') {
                // 应用平滑度
                const dist = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
                if (dist > brushSize * (1 - smoothness)) {
                    hullPoints.push({x, y});
                    lastX = x;
                    lastY = y;
                }
            } else if (currentTool === 'erase') {
                erasePoint(x, y);
            }
            
            drawScene();
            e.preventDefault();
        }
        
        // 结束绘制
        function endDrawing(e) {
            isDrawing = false;
            
            // 确保形状闭合
            if (currentTool === 'pencil' && hullPoints.length > 2) {
                hullPoints.push({...hullPoints[0]});
            }
            
            drawScene();
            e.preventDefault();
        }
        
        // 擦除点
        function erasePoint(x, y) {
            const eraseRadius = brushSize * 2;
            for (let i = hullPoints.length - 1; i >= 0; i--) {
                const point = hullPoints[i];
                const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                if (distance < eraseRadius) {
                    hullPoints.splice(i, 1);
                }
            }
        }
        
        // 触摸事件处理
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                isDrawing = true;
                lastX = x;
                lastY = y;
                
                if (currentTool === 'pencil') {
                    hullPoints.push({x, y});
                } else if (currentTool === 'erase') {
                    erasePoint(x, y);
                }
                
                drawScene();
            }
            e.preventDefault();
        }
        
        function handleTouchMove(e) {
            if (!isDrawing) return;
            
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                if (currentTool === 'pencil') {
                    const dist = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
                    if (dist > brushSize * (1 - smoothness)) {
                        hullPoints.push({x, y});
                        lastX = x;
                        lastY = y;
                    }
                } else if (currentTool === 'erase') {
                    erasePoint(x, y);
                }
                
                drawScene();
            }
            e.preventDefault();
        }
        
        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                isDrawing = false;
                
                if (currentTool === 'pencil' && hullPoints.length > 2) {
                    hullPoints.push({...hullPoints[0]});
                }
                
                drawScene();
            }
            e.preventDefault();
        }
        
        // 开始模拟
        function startSimulation() {
            if (hullPoints.length < 3) {
                alert('请先绘制船体形状！');
                return;
            }
            
            isSimulating = true;
            startSimBtn.textContent = '停止模拟';
            
            calculatePhysics();
            animate();
        }
        
        // 停止模拟
        function stopSimulation() {
            isSimulating = false;
            startSimBtn.textContent = '开始模拟';
        }
        
        // 重置模拟
        function resetSimulation() {
            stopSimulation();
            hullPoints = [];
            displacement = 0;
            buoyancyForce = 0;
            draft = 0;
            stabilityValue = 0;
            updateDataDisplay();
            drawScene();
        }
        
        // 清除船体
        function clearHull() {
            hullPoints = [];
            drawScene();
        }
        
        // 动画循环
        function animate() {
            if (isSimulating) {
                calculatePhysics();
                drawScene();
                requestAnimationFrame(animate);
            }
        }
        
        // 初始化
        function init() {
            resizeCanvas();
            initEventListeners();
            animate();
            
            // 设置默认选中的材质
            document.querySelector('.material-btn.steel').classList.add('selected');
        }
        
        // 启动应用
        init();
    </script>
</body>
</html>
